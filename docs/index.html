<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.39">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Brynjólfur Gauti Guðrúnar Jónsson">
<meta name="dcterms.date" content="2024-12-18">

<title>Applying Max-and-Smooth to the UKCP data</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-e26003cea8cd680ca0c55a263523d882.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-81e35ebdb4125010edbabe6010586085.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script async="" src="https://hypothes.is/embed.js"></script>
<script>
  window.document.addEventListener("DOMContentLoaded", function (_event) {
    document.body.classList.add('hypothesis-enabled');
  });
</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<meta name="citation_title" content="Applying Max-and-Smooth to the UKCP data">
<meta name="citation_author" content="Brynjólfur Gauti Guðrúnar Jónsson">
<meta name="citation_publication_date" content="2024-12-18">
<meta name="citation_cover_date" content="2024-12-18">
<meta name="citation_year" content="2024">
<meta name="citation_online_date" content="2024-12-18">
<meta name="citation_language" content="en">
</head>

<body>

<header id="title-block-header" class="quarto-title-block default toc-left page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Applying Max-and-Smooth to the UKCP data</h1>
          </div>

    
    <div class="quarto-title-meta-container">
      <div class="quarto-title-meta-column-start">
        
        <div class="quarto-title-meta">

                <div>
            <div class="quarto-title-meta-heading">Author</div>
            <div class="quarto-title-meta-contents">
                        <p>Brynjólfur Gauti Guðrúnar Jónsson </p>
                      </div>
          </div>
                
                <div>
            <div class="quarto-title-meta-heading">Published</div>
            <div class="quarto-title-meta-contents">
              <p class="date">December 18, 2024</p>
            </div>
          </div>
          
                
              </div>
      </div>
      <div class="quarto-title-meta-column-end quarto-other-formats-target">
      <div class="quarto-alternate-formats"><div class="quarto-title-meta-heading">Other Formats</div><div class="quarto-title-meta-contents"><p><a href="index.docx"><i class="bi bi-file-word"></i>MS Word</a></p></div><div class="quarto-title-meta-contents"><p><a href="index.pdf"><i class="bi bi-file-pdf"></i>PDF</a></p></div><div class="quarto-title-meta-contents"><p><a href="index-meca.zip" data-meca-link="true"><i class="bi bi-archive"></i>MECA Bundle</a></p></div></div></div>
    </div>



    <div class="quarto-other-links-text-target">
    <div class="quarto-code-links"><div class="quarto-title-meta-heading">Code Links</div><div class="quarto-title-meta-contents"><span><a href="https://github.com/bgautijonsson/maxandsmooth"><i class="bi bi-github"></i>GitHub Repo</a></span></div></div></div>  </div>
</header><div id="quarto-content" class="page-columns page-rows-contents page-layout-article toc-left">
<div id="quarto-sidebar-toc-left" class="sidebar toc-left">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">Introduction</a>
  <ul class="collapse">
  <li><a href="#package-overview" id="toc-package-overview" class="nav-link" data-scroll-target="#package-overview">Package Overview</a></li>
  <li><a href="#algorithm-description" id="toc-algorithm-description" class="nav-link" data-scroll-target="#algorithm-description">Algorithm Description</a>
  <ul class="collapse">
  <li><a href="#overview" id="toc-overview" class="nav-link" data-scroll-target="#overview">Overview</a></li>
  <li><a href="#inference-steps" id="toc-inference-steps" class="nav-link" data-scroll-target="#inference-steps">Inference Steps</a></li>
  <li><a href="#key-features" id="toc-key-features" class="nav-link" data-scroll-target="#key-features">Key Features</a></li>
  <li><a href="#implementation" id="toc-implementation" class="nav-link" data-scroll-target="#implementation">Implementation</a></li>
  </ul></li>
  <li><a href="#code-structure" id="toc-code-structure" class="nav-link" data-scroll-target="#code-structure">Code Structure</a></li>
  </ul></li>
  <li><a href="#max-step" id="toc-max-step" class="nav-link" data-scroll-target="#max-step">Max Step</a>
  <ul class="collapse">
  <li><a href="#data-structure-and-model-specification" id="toc-data-structure-and-model-specification" class="nav-link" data-scroll-target="#data-structure-and-model-specification">Data Structure and Model Specification</a></li>
  <li><a href="#log-likelihood-function" id="toc-log-likelihood-function" class="nav-link" data-scroll-target="#log-likelihood-function">Log-likelihood Function</a></li>
  <li><a href="#implementation-details" id="toc-implementation-details" class="nav-link" data-scroll-target="#implementation-details">Implementation Details</a></li>
  </ul></li>
  <li><a href="#smooth-step" id="toc-smooth-step" class="nav-link" data-scroll-target="#smooth-step">Smooth Step</a>
  <ul class="collapse">
  <li><a href="#model-structure" id="toc-model-structure" class="nav-link" data-scroll-target="#model-structure">Model Structure</a>
  <ul class="collapse">
  <li><a href="#spatial-random-effects" id="toc-spatial-random-effects" class="nav-link" data-scroll-target="#spatial-random-effects">Spatial Random Effects</a></li>
  <li><a href="#icar-prior-specification" id="toc-icar-prior-specification" class="nav-link" data-scroll-target="#icar-prior-specification">ICAR Prior Specification</a></li>
  <li><a href="#observation-model" id="toc-observation-model" class="nav-link" data-scroll-target="#observation-model">Observation Model</a></li>
  <li><a href="#prior-distributions" id="toc-prior-distributions" class="nav-link" data-scroll-target="#prior-distributions">Prior Distributions</a></li>
  </ul></li>
  <li><a href="#posterior-inference" id="toc-posterior-inference" class="nav-link" data-scroll-target="#posterior-inference">Posterior Inference</a></li>
  </ul></li>
  </ul>
</nav>
</div>
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
</div>
<main class="content quarto-banner-title-block" id="quarto-document-content">



  


<section id="introduction" class="level1">
<h1>Introduction</h1>
<p>This document describes the implementation of the Max-and-Smooth algorithm for fast approximate Bayesian inference in spatial extreme value analysis of climate projections provided by the UKCP. The algorithm is specifically applied to Generalized Extreme Value (GEV) distributions and is implemented in C++ with R interfaces using Rcpp and RcppEigen as well as Stan.</p>
<section id="package-overview" class="level2">
<h2 class="anchored" data-anchor-id="package-overview">Package Overview</h2>
<p>The <code>maxandsmooth</code> R package provides tools for fast approximate Bayesian inference for spatial GEV models. The core of the package is implemented in C++ for efficiency, with R wrappers for ease of use.</p>
<p>Key features of the package include:</p>
<ul>
<li>Implementation of the Max-and-Smooth algorithm with Gaussian copula dependence</li>
<li>Efficient C++ code using automatic differentiation and Eigen</li>
<li>Spatial modeling of GEV parameters using Stan’s efficient HMC sampler</li>
<li>R interface for easy integration into existing extreme value analysis workflows</li>
</ul>
</section>
<section id="algorithm-description" class="level2">
<h2 class="anchored" data-anchor-id="algorithm-description">Algorithm Description</h2>
<p>The Max-and-Smooth algorithm provides a computationally efficient approach to Bayesian inference for spatial extreme value models by decomposing the inference into two steps. This approach is particularly well-suited for spatial GEV models where we have both temporal replicates and spatial dependence.</p>
<section id="overview" class="level3">
<h3 class="anchored" data-anchor-id="overview">Overview</h3>
<p>Let <span class="math inline">\(Y = \{y_{it}\}\)</span> be observations at locations <span class="math inline">\(i=1,\ldots,p\)</span> and times <span class="math inline">\(t=1,\ldots,n\)</span>. We model these through GEV marginal distributions with spatially varying parameters and a Gaussian copula dependence structure:</p>
<ol type="1">
<li><p><strong>Marginal Distribution</strong>: At each location <span class="math inline">\(i\)</span>: <span class="math display">\[Y_{it} \sim \mathrm{GEV}(\mu_i, \sigma_i, \xi_i)\]</span></p></li>
<li><p><strong>Dependence Structure</strong>: Transform to Gaussian margins via: <span class="math display">\[Z_{it} = \Phi^{-1}(F_{\mathrm{GEV}}(Y_{it}|\mu_i,\sigma_i,\xi_i))\]</span> where the spatial dependence is captured through a Matérn-like precision structure: <span class="math display">\[Z_t \sim \mathcal{N}(0, Q^{-1}), \quad Q = (Q_{\rho_1} \otimes I_{n_2} + I_{n_1} \otimes Q_{\rho_2})^{\nu+1}\]</span></p></li>
</ol>
</section>
<section id="inference-steps" class="level3">
<h3 class="anchored" data-anchor-id="inference-steps">Inference Steps</h3>
<p>The algorithm proceeds in two main steps:</p>
<ol type="1">
<li><strong>Max Step</strong>: Joint maximum likelihood estimation
<ul>
<li>Input: Raw observations <span class="math inline">\(Y\)</span></li>
<li>Process:
<ol type="a">
<li>Transform parameters: <span class="math inline">\((\psi,\tau,\phi) = (\log\mu, \log\sigma-\log\mu, \text{logit}(\xi))\)</span></li>
<li>Maximize joint log-likelihood combining GEV margins and Gaussian copula</li>
<li>Compute Hessian at MLE for uncertainty quantification</li>
</ol></li>
<li>Output:
<ul>
<li>MLEs <span class="math inline">\(\hat{\eta} = (\hat{\psi}, \hat{\tau}, \hat{\phi})\)</span></li>
<li>Precision matrix <span class="math inline">\(Q_{\eta y}\)</span> (negative Hessian)</li>
</ul></li>
</ul></li>
<li><strong>Smooth Step</strong>: Spatial smoothing via BYM2 model
<ul>
<li>Input: MLEs <span class="math inline">\(\hat{\eta}\)</span> and precision <span class="math inline">\(Q_{\eta y}\)</span> from Max step</li>
<li>Process: For each parameter type <span class="math inline">\(k \in \{\psi, \tau, \phi\}\)</span>:
<ol type="a">
<li>Decompose into spatial and random components: <span class="math display">\[\eta_k = \mu_k\mathbf{1} + \sigma_k(\sqrt{\rho_k/c}\eta^{\mathrm{spatial}}_k + \sqrt{1-\rho_k}\eta^{\mathrm{random}}_k)\]</span></li>
<li>Apply ICAR prior to spatial component</li>
<li>Sample posterior using MCMC</li>
</ol></li>
<li>Output: Posterior samples of smoothed parameters</li>
</ul></li>
</ol>
</section>
<section id="key-features" class="level3">
<h3 class="anchored" data-anchor-id="key-features">Key Features</h3>
<p>The algorithm offers several computational advantages:</p>
<ol type="1">
<li><strong>Parallel Processing</strong>: The Max step can be parallelized across locations</li>
<li><strong>Dimensionality Reduction</strong>: The Smooth step works with summary statistics (MLEs) rather than raw data</li>
<li><strong>Efficient Sampling</strong>: Uses Stan’s NUTS sampler with sparse matrix operations</li>
<li><strong>Uncertainty Propagation</strong>: Incorporates parameter uncertainty through <span class="math inline">\(Q_{\eta y}\)</span></li>
</ol>
</section>
<section id="implementation" class="level3">
<h3 class="anchored" data-anchor-id="implementation">Implementation</h3>
<p>The method is implemented using:</p>
<ol type="1">
<li>C++ with automatic differentiation for the Max step:
<ul>
<li>Efficient computation of GEV density and transformations</li>
<li>Sparse matrix operations for Gaussian copula likelihood</li>
<li>L-BFGS optimization with analytical gradients</li>
</ul></li>
<li>Stan for the Smooth step:
<ul>
<li>BYM2 spatial model with PC priors</li>
<li>Custom functions for sparse precision matrices</li>
<li>Efficient HMC sampling</li>
</ul></li>
</ol>
<p>This two-step approach provides a computationally tractable alternative to full MCMC for spatial extreme value models while maintaining proper uncertainty quantification through the entire inference pipeline.</p>
</section>
</section>
<section id="code-structure" class="level2">
<h2 class="anchored" data-anchor-id="code-structure">Code Structure</h2>
<p>The package is organized into several key files:</p>
<ol type="1">
<li><code>src/gev_reverse_mode.cpp</code>: Implements the Max step (maximum likelihood estimation for GEV) assuming a known Gaussian copula</li>
<li><code>Stan/stan_smooth_bym2.stan</code> Implements the Smooth step using Stan</li>
</ol>
</section>
</section>
<section id="max-step" class="level1">
<h1>Max Step</h1>
<p>The Max step involves computing location-wise maximum likelihood estimates (MLEs) for the GEV model parameters while accounting for spatial dependence through a Matérn-like Gaussian copula structure.</p>
<section id="data-structure-and-model-specification" class="level2">
<h2 class="anchored" data-anchor-id="data-structure-and-model-specification">Data Structure and Model Specification</h2>
<p>Let <span class="math inline">\(Y\)</span> be an <span class="math inline">\(n \times p\)</span> matrix of observations where:</p>
<ul>
<li>Rows <span class="math inline">\((i=1,\ldots,n)\)</span> represent temporal replicates</li>
<li>Columns <span class="math inline">\((j=1,\ldots,p)\)</span> represent spatial locations</li>
</ul>
<p>The model combines GEV marginal distributions with a Gaussian copula:</p>
<ol type="1">
<li><p><strong>Marginal GEV distributions</strong>: At each location <span class="math inline">\(j\)</span>, observations follow a GEV distribution: <span class="math display">\[Y_{ij} \sim \text{GEV}(\mu_j, \sigma_j, \xi_j)\]</span></p></li>
<li><p><strong>Spatial dependence</strong>: The dependence structure is captured by transforming the observations to standard normal using the prowbability integral transform: <span class="math display">\[Z_{ij} = \Phi^{-1}(F_{\text{GEV}}(Y_{ij}|\mu_j,\sigma_j,\xi_j))\]</span> where <span class="math inline">\(F_{\text{GEV}}\)</span> is the GEV CDF and <span class="math inline">\(\Phi^{-1}\)</span> is the standard normal quantile function.</p></li>
<li><p><strong>Matérn-like precision structure</strong>: The transformed observations follow a multivariate normal distribution with precision matrix: <span class="math display">\[Q = (Q_{\rho_1} \otimes I_{n_2} + I_{n_1} \otimes Q_{\rho_2})^{\nu+1}\]</span> where:</p>
<ul>
<li><span class="math inline">\(Q_{\rho}\)</span> is the precision matrix of a standardized AR(1) process</li>
<li><span class="math inline">\(\otimes\)</span> denotes the Kronecker product</li>
<li><span class="math inline">\(\nu\)</span> is a smoothness parameter</li>
<li>The matrix is scaled to ensure unit marginal variances</li>
</ul></li>
</ol>
</section>
<section id="log-likelihood-function" class="level2">
<h2 class="anchored" data-anchor-id="log-likelihood-function">Log-likelihood Function</h2>
<p>The total log-likelihood combines the GEV marginal contributions and the Gaussian copula:</p>
<p><span class="math display">\[\ell(\theta|Y) = \sum_{j=1}^p \sum_{i=1}^n \ell_{\text{GEV}}(y_{ij}|\mu_j,\sigma_j,\xi_j) + \ell_{\text{copula}}(Z|Q)\]</span></p>
<p>where:</p>
<ol type="1">
<li><p>The GEV log-likelihood for a single observation is: <span class="math display">\[\ell_{\text{GEV}}(y|\mu,\sigma,\xi) = -\log\sigma - (1+\frac{1}{\xi})\log(1+\xi\frac{y-\mu}{\sigma}) - (1+\xi\frac{y-\mu}{\sigma})^{-1/\xi}\]</span></p></li>
<li><p>The Gaussian copula log-likelihood is: <span class="math display">\[\ell_{\text{copula}}(Z|Q) = \frac{1}{2}\log|Q| - \frac{1}{2}Z^TQZ + \frac{1}{2}Z^TZ\]</span> where the last term accounts for the standard normal margins.</p></li>
</ol>
</section>
<section id="implementation-details" class="level2">
<h2 class="anchored" data-anchor-id="implementation-details">Implementation Details</h2>
<p>The optimization is performed using automatic differentiation and the L-BFGS algorithm. Key implementation features include:</p>
<ol type="1">
<li><p><strong>Parameter transformations</strong>: <span class="math display">\[(\psi,\tau,\phi) = (\log\mu, \log\sigma-\log\mu, \text{logit}(\xi))\]</span></p></li>
<li><p><strong>Efficient computation</strong> of the quadratic form <span class="math inline">\(Z^TQZ\)</span> and log-determinant <span class="math inline">\(\log|Q|\)</span> by exploiting the Kronecker structure of the precision matrix</p></li>
<li><p><strong>Probability integral transform</strong> using accurate approximations to the GEV CDF and normal quantile function</p></li>
<li><p><strong>Automatic differentiation</strong> (using autodiff’s reverse mode) for accurate gradient and Hessian computation</p></li>
</ol>
</section>
</section>
<section id="smooth-step" class="level1">
<h1>Smooth Step</h1>
<p>The Smooth step performs Bayesian inference on the latent parameter fields using the maximum likelihood estimates from the Max step as noisy observations. We implement this using Stan’s efficient Hamiltonian Monte Carlo sampler with a BYM2 (Besag-York-Mollié) spatial model.</p>
<section id="model-structure" class="level2">
<h2 class="anchored" data-anchor-id="model-structure">Model Structure</h2>
<p>Let <span class="math inline">\(\hat{\eta}\)</span> be the vector of maximum likelihood estimates from the Max step, arranged as:</p>
<p><span class="math display">\[\hat{\eta} = (\hat{\psi}_1,\ldots,\hat{\psi}_p, \hat{\tau}_1,\ldots,\hat{\tau}_p, \hat{\phi}_1,\ldots,\hat{\phi}_p)^T\]</span></p>
<p>where <span class="math inline">\(p\)</span> is the number of spatial locations and <span class="math inline">\((\hat{\psi}, \hat{\tau}, \hat{\phi})\)</span> represent the transformed GEV parameters.</p>
<section id="spatial-random-effects" class="level3">
<h3 class="anchored" data-anchor-id="spatial-random-effects">Spatial Random Effects</h3>
<p>For each parameter type <span class="math inline">\(k \in \{\psi, \tau, \phi\}\)</span>, we decompose the spatial variation into structured and unstructured components following the BYM2 parameterization:</p>
<p><span class="math display">\[\eta_k = \mu_k\mathbf{1} + \sigma_k\left(\sqrt{\frac{\rho_k}{c}}\eta^{\mathrm{spatial}}_k + \sqrt{1-\rho_k}\eta^{\mathrm{random}}_k\right)\]</span></p>
<p>where:</p>
<ul>
<li><span class="math inline">\(\mu_k\)</span> is the overall mean</li>
<li><span class="math inline">\(\sigma_k &gt; 0\)</span> is the marginal standard deviation</li>
<li><span class="math inline">\(\rho_k \in [0,1]\)</span> is the mixing parameter controlling the balance between spatial and unstructured variation</li>
<li><span class="math inline">\(c\)</span> is a scaling factor that ensures the marginal variance of the spatial component is approximately 1</li>
<li><span class="math inline">\(\eta^{\mathrm{spatial}}_k\)</span> follows an intrinsic conditional autoregressive (ICAR) prior</li>
<li><span class="math inline">\(\eta^{\mathrm{random}}_k \sim \mathcal{N}(0, I)\)</span> represents unstructured random effects</li>
</ul>
</section>
<section id="icar-prior-specification" class="level3">
<h3 class="anchored" data-anchor-id="icar-prior-specification">ICAR Prior Specification</h3>
<p>The ICAR prior for the spatial component <span class="math inline">\(\eta^{\mathrm{spatial}}_k\)</span> is specified through its full conditional distributions:</p>
<p><span class="math display">\[\eta^{\mathrm{spatial}}_{k,i} | \eta^{\mathrm{spatial}}_{k,-i} \sim \mathcal{N}\left(\frac{1}{n_i}\sum_{j \sim i} \eta^{\mathrm{spatial}}_{k,j}, \frac{1}{n_i}\right)\]</span></p>
<p>where <span class="math inline">\(j \sim i\)</span> indicates that locations <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> are neighbors, and <span class="math inline">\(n_i\)</span> is the number of neighbors for location <span class="math inline">\(i\)</span>. This is implemented efficiently in Stan through the sum of squared differences form:</p>
<p><span class="math display">\[p(\eta^{\mathrm{spatial}}_k) \propto \exp\left(-\frac{1}{2}\sum_{i \sim j} (\eta^{\mathrm{spatial}}_{k,i} - \eta^{\mathrm{spatial}}_{k,j})^2\right)\]</span></p>
<p>with an additional soft sum-to-zero constraint implemented via <span class="math inline">\(\sum_i \eta^{\mathrm{spatial}}_{k,i} \sim \mathcal{N}(0, 0.001p)\)</span>.</p>
</section>
<section id="observation-model" class="level3">
<h3 class="anchored" data-anchor-id="observation-model">Observation Model</h3>
<p>The observation model links the MLEs to the latent field through a multivariate normal distribution:</p>
<p><span class="math display">\[\hat{\eta} | \eta \sim \mathcal{N}(\eta, Q^{-1}_{\eta y})\]</span></p>
<p>where <span class="math inline">\(Q_{\eta y}\)</span> is the precision matrix obtained from the negative Hessian in the Max step. To handle this efficiently in Stan, we:</p>
<ol type="1">
<li>Pre-compute the Cholesky factor <span class="math inline">\(L\)</span> of <span class="math inline">\(Q_{\eta y} = LL^T\)</span></li>
<li>Store <span class="math inline">\(L\)</span> in a sparse format using arrays of indices and values</li>
<li>Implement a custom log probability function that computes: <span class="math display">\[\log p(\hat{\eta}|\eta) = \frac{1}{2}\log|Q_{\eta y}| - \frac{1}{2}(\hat{\eta} - \eta)^T Q_{\eta y}(\hat{\eta} - \eta)\]</span> using the sparse Cholesky representation</li>
</ol>
</section>
<section id="prior-distributions" class="level3">
<h3 class="anchored" data-anchor-id="prior-distributions">Prior Distributions</h3>
<p>We specify weakly informative priors:</p>
<p><span class="math display">\[
\begin{aligned}
\sigma_k &amp;\sim \mathrm{Exponential}(1) \\
\rho_k &amp;\sim \mathrm{Beta}(1,1) \\
\mu_k &amp;\sim \mathrm{flat}
\end{aligned}
\]</span></p>
<p>for each parameter type <span class="math inline">\(k\)</span>. The exponential prior on <span class="math inline">\(\sigma_k\)</span> provides weak regularization while ensuring positivity, while the uniform Beta prior on <span class="math inline">\(\rho_k\)</span> allows the data to determine the balance between spatial and unstructured variation.</p>
</section>
</section>
<section id="posterior-inference" class="level2">
<h2 class="anchored" data-anchor-id="posterior-inference">Posterior Inference</h2>
<p>The model is fit using Stan’s implementation of the No-U-Turn Sampler (NUTS), providing:</p>
<ol type="1">
<li>Posterior samples of the latent field <span class="math inline">\(\eta\)</span></li>
<li>Uncertainty quantification through the posterior distributions of <span class="math inline">\(\mu_k\)</span>, <span class="math inline">\(\sigma_k\)</span>, and <span class="math inline">\(\rho_k\)</span></li>
<li>Decomposition of spatial variation through the posterior distributions of <span class="math inline">\(\eta^{\mathrm{spatial}}_k\)</span> and <span class="math inline">\(\eta^{\mathrm{random}}_k\)</span></li>
</ol>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>