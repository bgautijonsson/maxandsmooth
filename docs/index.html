<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Brynjólfur Gauti Guðrúnar Jónsson">
<meta name="dcterms.date" content="2024-10-09">

<title>Applying Max-and-Smooth to the UKCP data</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script async="" src="https://hypothes.is/embed.js"></script>
<script>
  window.document.addEventListener("DOMContentLoaded", function (_event) {
    document.body.classList.add('hypothesis-enabled');
  });
</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<meta name="citation_title" content="Applying Max-and-Smooth to the UKCP data">
<meta name="citation_author" content="Brynjólfur Gauti Guðrúnar Jónsson">
<meta name="citation_publication_date" content="2024-10-09">
<meta name="citation_cover_date" content="2024-10-09">
<meta name="citation_year" content="2024">
<meta name="citation_online_date" content="2024-10-09">
<meta name="citation_language" content="en">
</head>

<body>

<header id="title-block-header" class="quarto-title-block default toc-left page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Applying Max-and-Smooth to the UKCP data</h1>
          </div>

    
    <div class="quarto-title-meta-container">
      <div class="quarto-title-meta-column-start">
        
        <div class="quarto-title-meta">

                <div>
            <div class="quarto-title-meta-heading">Author</div>
            <div class="quarto-title-meta-contents">
                        <p>Brynjólfur Gauti Guðrúnar Jónsson </p>
                      </div>
          </div>
                
                <div>
            <div class="quarto-title-meta-heading">Published</div>
            <div class="quarto-title-meta-contents">
              <p class="date">October 9, 2024</p>
            </div>
          </div>
          
                
              </div>
      </div>
      <div class="quarto-title-meta-column-end quarto-other-formats-target">
      <div class="quarto-alternate-formats"><div class="quarto-title-meta-heading">Other Formats</div><div class="quarto-title-meta-contents"><p><a href="index.docx"><i class="bi bi-file-word"></i>MS Word</a></p></div><div class="quarto-title-meta-contents"><p><a href="index.pdf"><i class="bi bi-file-pdf"></i>PDF</a></p></div><div class="quarto-title-meta-contents"><p><a href="index-meca.zip" data-meca-link="true"><i class="bi bi-archive"></i>MECA Bundle</a></p></div></div></div>
    </div>



    <div class="quarto-other-links-text-target">
    <div class="quarto-code-links"><div class="quarto-title-meta-heading">Code Links</div><div class="quarto-title-meta-contents"><span><a href="https://github.com/bgautijonsson/maxandsmooth"><i class="bi bi-github"></i>GitHub Repo</a></span></div></div></div>  </div>
</header><div id="quarto-content" class="page-columns page-rows-contents page-layout-article toc-left">
<div id="quarto-sidebar-toc-left" class="sidebar toc-left">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">Introduction</a>
  <ul class="collapse">
  <li><a href="#package-overview" id="toc-package-overview" class="nav-link" data-scroll-target="#package-overview">Package Overview</a></li>
  <li><a href="#algorithm-description" id="toc-algorithm-description" class="nav-link" data-scroll-target="#algorithm-description">Algorithm Description</a></li>
  <li><a href="#code-structure" id="toc-code-structure" class="nav-link" data-scroll-target="#code-structure">Code Structure</a></li>
  </ul></li>
  <li><a href="#max-step" id="toc-max-step" class="nav-link" data-scroll-target="#max-step">Max Step</a>
  <ul class="collapse">
  <li><a href="#data-structure" id="toc-data-structure" class="nav-link" data-scroll-target="#data-structure">Data Structure</a></li>
  <li><a href="#maximum-likelihood-estimation" id="toc-maximum-likelihood-estimation" class="nav-link" data-scroll-target="#maximum-likelihood-estimation">Maximum Likelihood Estimation</a>
  <ul class="collapse">
  <li><a href="#link-functions" id="toc-link-functions" class="nav-link" data-scroll-target="#link-functions">Link Functions</a></li>
  </ul></li>
  <li><a href="#implementation" id="toc-implementation" class="nav-link" data-scroll-target="#implementation">Implementation</a></li>
  </ul></li>
  <li><a href="#smooth-step" id="toc-smooth-step" class="nav-link" data-scroll-target="#smooth-step">Smooth Step</a>
  <ul class="collapse">
  <li><a href="#model-structure" id="toc-model-structure" class="nav-link" data-scroll-target="#model-structure">Model Structure</a>
  <ul class="collapse">
  <li><a href="#data-level" id="toc-data-level" class="nav-link" data-scroll-target="#data-level">Data Level</a></li>
  <li><a href="#latent-level" id="toc-latent-level" class="nav-link" data-scroll-target="#latent-level">Latent Level</a></li>
  <li><a href="#hyperparameter-level" id="toc-hyperparameter-level" class="nav-link" data-scroll-target="#hyperparameter-level">Hyperparameter Level</a></li>
  </ul></li>
  <li><a href="#mcmc-sampling" id="toc-mcmc-sampling" class="nav-link" data-scroll-target="#mcmc-sampling">MCMC Sampling</a>
  <ul class="collapse">
  <li><a href="#latent-field-sampling" id="toc-latent-field-sampling" class="nav-link" data-scroll-target="#latent-field-sampling">Latent Field Sampling</a></li>
  </ul></li>
  </ul></li>
  
  </ul>
</nav>
</div>
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
</div>
<main class="content quarto-banner-title-block" id="quarto-document-content">



  


<section id="introduction" class="level1">
<h1>Introduction</h1>
<p>This document describes the implementation of the Max-and-Smooth algorithm for fast approximate Bayesian inference in spatial extreme value analysis of climate projections provided by the UKCP. The algorithm is specifically applied to Generalized Extreme Value (GEV) distributions and is implemented in C++ with R interfaces using Rcpp and RcppEigen.</p>
<section id="package-overview" class="level2">
<h2 class="anchored" data-anchor-id="package-overview">Package Overview</h2>
<p>The <code>maxandsmooth</code> R package provides tools for fast approximate Bayesian inference for spatial GEV models. The core of the package is implemented in C++ for efficiency, with R wrappers for ease of use.</p>
<p>Key features of the package include:</p>
<ul>
<li>Implementation of the Max-and-Smooth algorithm for GEV distributions</li>
<li>Efficient C++ code using Eigen for linear algebra operations</li>
<li>Spatial modeling of GEV parameters using Intrinsic Conditional Autoregressive (ICAR) priors</li>
<li>R interface for easy integration into existing extreme value analysis workflows</li>
</ul>
</section>
<section id="algorithm-description" class="level2">
<h2 class="anchored" data-anchor-id="algorithm-description">Algorithm Description</h2>
<p>The Max-and-Smooth algorithm, as applied to spatial GEV models, consists of two main steps:</p>
<ol type="1">
<li><strong>Max Step</strong>: Maximum likelihood estimation of GEV parameters at each spatial location</li>
<li><strong>Smooth Step</strong>: Spatial smoothing of the maximum likelihood estimates using a latent Gaussian field</li>
</ol>
<p>The algorithm treats the ML estimates as sufficient statistics for a latent Gaussian field, providing a fast approximation to full Bayesian inference for spatial extreme value models.</p>
</section>
<section id="code-structure" class="level2">
<h2 class="anchored" data-anchor-id="code-structure">Code Structure</h2>
<p>The package is organized into several key files:</p>
<ol type="1">
<li><code>src/max.cpp</code>: Implements the Max step (maximum likelihood estimation for GEV)</li>
<li><code>src/smooth.cpp</code>: Implements the Smooth step (latent Gaussian field smoothing)</li>
<li><code>src/maxandsmooth.cpp</code>: Ties together the Max and Smooth steps</li>
<li><code>src/gev.cpp</code>: Implements GEV-specific functions for likelihood and gradient calculations</li>
</ol>
</section>
</section>
<section id="max-step" class="level1">
<h1>Max Step</h1>
<p>The Max step involves computing location-wise maximum likelihood estimates (MLEs) for the GEV model parameters. This step is performed independently for each location, treating the data as if it were independent across locations.</p>
<section id="data-structure" class="level2">
<h2 class="anchored" data-anchor-id="data-structure">Data Structure</h2>
<p>The input data Y, calculated from the UKCP, is structured as a matrix, where:</p>
<ul>
<li>Rows represent observations of hourly maximum rainfall in yearly blocks</li>
<li>Columns represent different spatial locations over Great Britain.</li>
</ul>
</section>
<section id="maximum-likelihood-estimation" class="level2">
<h2 class="anchored" data-anchor-id="maximum-likelihood-estimation">Maximum Likelihood Estimation</h2>
<p>For each location (column in Y), we compute the MLEs for the three GEV parameters: location <span class="math inline">\((\mu)\)</span>, scale <span class="math inline">\((\sigma)\)</span>, and shape <span class="math inline">\((\xi)\)</span>. The log-likelihood function for the GEV distribution at a single location is:</p>
<p><span class="math display">\[
\ell(\mu, \sigma, \xi | y) = -n\log\sigma - (1+\frac{1}{\xi})\sum_{i=1}^n \log\left(1+\xi\frac{y_i-\mu}{\sigma}\right) - \sum_{i=1}^n \left(1+\xi\frac{y_i-\mu}{\sigma}\right)^{-1/\xi}
\]</span></p>
<p>where <span class="math inline">\(n\)</span> is the number of observations at the location.</p>
<p>The MLEs are obtained by maximizing this likelihood function with respect to the parameters:</p>
<p><span class="math display">\[
(\hat{\mu}_i, \hat{\sigma}_i, \hat{\xi}_i) = \arg\max_{(\mu, \sigma, \xi)} \ell(\mu, \sigma, \xi | Y_i)
\]</span></p>
<p>where <span class="math inline">\(Y_i\)</span> is the data for location <span class="math inline">\(i\)</span>.</p>
<section id="link-functions" class="level3">
<h3 class="anchored" data-anchor-id="link-functions">Link Functions</h3>
<p>Instead of directly maximizing the likelihood with the original parameters, we transform the parameters using a link function</p>
<p><span class="math display">\[
\left(\psi, \tau, \phi\right) = h(\mu, \sigma, \xi) = \left(\log(\mu), \log(\sigma) - \log(\mu), \text{logit}(\xi)\right)
\]</span></p>
</section>
</section>
<section id="implementation" class="level2">
<h2 class="anchored" data-anchor-id="implementation">Implementation</h2>
<p>The maximization is performed using numerical optimization techniques. In our C++ implementation, we use the following approach:</p>
<ol type="1">
<li>Parameters are transformed with a link function</li>
<li>The negative log-likelihood and its gradient are computed on the unconstrained scale</li>
<li>A numerical optimizer is used to find the MLEs as well as the Hessians at each location’s optimum.</li>
</ol>
<p>The output of this step includes:</p>
<ol type="1">
<li><p>A vector of parameter estimates, <span class="math inline">\(\hat\eta\)</span>, ordered such that each station’s location parameter appears first, followed by scale parameters, then shape parameters:</p>
<p><span class="math display">\[
\hat{\eta} = (\hat{\psi}_1, \ldots, \hat{\psi}_n, \hat{\tau}_1, \ldots, \hat{\tau}_n, \hat{\phi}_1, \ldots, \hat{\phi}_n)^T
\]</span></p>
<p>where <span class="math inline">\(n\)</span> is the number of stations.</p></li>
<li><p>A precision matrix, <span class="math inline">\(Q_{\eta y}\)</span>, constructed from the negative Hessians of the log-likelihood at the MLE estimates. Due to the parameter ordering in <span class="math inline">\(\hat\eta\)</span>, <span class="math inline">\(Q_{\eta y}\)</span> can be described as a 3×3 block matrix:</p>
<p><span class="math display">\[
Q_{\eta y} = \begin{bmatrix}
Q_{\psi\psi} &amp; Q_{\psi\tau} &amp; Q_{\psi\phi} \\
Q_{\tau\psi} &amp; Q_{\tau\tau} &amp; Q_{\tau\phi} \\
Q_{\phi\psi} &amp; Q_{\psi\tau} &amp; Q_{\phi\phi}
\end{bmatrix}
\]</span></p>
<p>where each block <span class="math inline">\(Q_{ij}\)</span> is an <span class="math inline">\(n \times n\)</span> diagonal matrix. The diagonal elements of <span class="math inline">\(Q_{ii}\)</span> correspond to the negative second derivatives of the log-likelihood with respect to the <span class="math inline">\(i\)</span>-th parameter at each station. The off-diagonal blocks <span class="math inline">\(Q_{ij}\)</span> (where <span class="math inline">\(i \neq j\)</span>) contain the negative mixed partial derivatives of the log-likelihood with respect to the <span class="math inline">\(i\)</span>-th and <span class="math inline">\(j\)</span>-th parameters.</p>
<p>For example, the elements of <span class="math inline">\(Q_{\psi\psi}\)</span> are the conditional precisions of the location parameters:</p>
<p><span class="math display">\[
\begin{aligned}
Q_{\psi\psi} &amp;=  \text{diag}\left(\tau^{\psi\psi}_1, \dots, \tau^{\psi\psi}_n\right)\\
&amp;= \text{diag}\left(-\frac{\partial^2 \ell(Y_1|\psi_1,\tau_1,\phi_1)}{\partial \psi_1^2}, \ldots, -\frac{\partial^2 \ell(Y_n|\psi_n,\tau_n,\phi_n)}{\partial \psi_n^2}\right),
\end{aligned}
\]</span></p>
<p>and the elements of <span class="math inline">\(Q_{\mu\xi}\)</span> are the conditional dependencies between the location and shape parameters:</p>
<p><span class="math display">\[
\begin{aligned}
Q_{\psi\phi} &amp;= \text{diag}\left(\tau^{\psi\phi}_1, \dots, \tau^{\psi\phi}_n\right) \\
&amp;= \text{diag}\left(-\frac{\partial^2 \ell(Y_1|\psi_1,\tau_1,\phi_1)}{\partial \psi_1\partial \phi_1}, \ldots, -\frac{\partial^2 \ell(Y_n|\psi_n,\tau_n,\phi_n)}{\partial \psi_n\partial \phi_n}\right)
\end{aligned}
\]</span></p></li>
</ol>
<p>This structure reflects the independence assumption between stations in the Max step, while capturing the parameter dependencies within each station. The outputs, <span class="math inline">\(\hat \eta\)</span> and <span class="math inline">\(Q_{\eta y}\)</span>, serve as inputs into the Smooth step.</p>
</section>
</section>
<section id="smooth-step" class="level1">
<h1>Smooth Step</h1>
<p>The Smooth step involves Bayesian inference on a latent Gaussian field, using the maximum likelihood estimates from the Max step as data.</p>
<section id="model-structure" class="level2">
<h2 class="anchored" data-anchor-id="model-structure">Model Structure</h2>
<p>Let <span class="math inline">\(\eta\)</span> be the latent field of parameters, and <span class="math inline">\(\hat{\eta}\)</span> be the maximum likelihood estimates from the Max step. The model is structured as follows:</p>
<ol type="1">
<li>Data level: <span class="math inline">\(\hat{\eta} | \eta \sim N(\eta, Q_{\eta y}^{-1})\)</span></li>
<li>Latent level: <span class="math inline">\(\eta | \tau_\eta \sim N(0, Q_\eta^{-1})\)</span></li>
<li>Hyperparameter level: <span class="math inline">\(\tau_\eta \sim \pi(\tau_\eta)\)</span></li>
</ol>
<p>where <span class="math inline">\(Q_{\eta y}\)</span> is the precision matrix from the Max step, and <span class="math inline">\(Q_\eta\)</span> is the precision matrix of the latent field, parameterized by hyperparameters <span class="math inline">\(\tau_\eta\)</span>.</p>
<section id="data-level" class="level3">
<h3 class="anchored" data-anchor-id="data-level">Data Level</h3>
<p>The data level models the relationship between the observed maximum likelihood estimates <span class="math inline">\(\hat{\eta}\)</span> and the true latent field <span class="math inline">\(\eta\)</span>:</p>
<p><span class="math display">\[\hat{\eta} | \eta \sim N(\eta, Q_{\eta y}^{-1})\]</span></p>
<p>Here, <span class="math inline">\(Q_{\eta y}\)</span> is the precision matrix obtained from the Max step, representing the uncertainty in the MLE estimates. This can be thought of as using the outputs of the Max step as sufficient statistics for the observed data.</p>
</section>
<section id="latent-level" class="level3">
<h3 class="anchored" data-anchor-id="latent-level">Latent Level</h3>
<p>The latent level models the spatial structure of the parameter field: <span class="math display">\[
\eta | \tau_\eta \sim N(0, Q_\eta^{-1})
\]</span></p>
<p>Here, <span class="math inline">\(Q_\eta\)</span> is a block diagonal precision matrix that encodes the spatial dependence structure of the latent field. The block diagonal structure reflects the assumption of independence between different parameters, while allowing for spatial correlation within each parameter field. The precision matrix <span class="math inline">\(Q_\eta\)</span> is constructed as follows:</p>
<p><span class="math display">\[
Q_\eta = \begin{bmatrix}
\tau_\psi Q_{\text{prior}} &amp; 0 &amp; 0 \\
0 &amp; \tau_\tau Q_{\text{prior}} &amp; 0 \\
0 &amp; 0 &amp; \tau_\phi Q_{\text{prior}}
\end{bmatrix}
\]</span></p>
<p>where</p>
<p><span class="math display">\[
Q_{\text{prior}} = \begin{bmatrix}
2 &amp; -1 \\
-1 &amp; 2 &amp; -1 \\
&amp; -1 &amp; 2 &amp; -1 \\
&amp; &amp; \vdots &amp; \vdots &amp; \vdots \\
&amp; &amp; &amp; -1 &amp; 2 &amp; -1 \\
&amp; &amp; &amp; &amp; -1 &amp; 2 &amp; -1 \\
&amp; &amp; &amp; &amp; &amp; -1 &amp; 2
\end{bmatrix}
\]</span></p>
<p>and <span class="math inline">\(\tau_\eta = \left(\tau_\psi, \tau_\tau, \tau_\phi\right)^T\)</span> are the hyperparameters controlling the strength of spatial dependence for each parameter.</p>
</section>
<section id="hyperparameter-level" class="level3">
<h3 class="anchored" data-anchor-id="hyperparameter-level">Hyperparameter Level</h3>
<p>The hyperparameters <span class="math inline">\(\tau_\eta\)</span> are assigned prior distributions.</p>
</section>
</section>
<section id="mcmc-sampling" class="level2">
<h2 class="anchored" data-anchor-id="mcmc-sampling">MCMC Sampling</h2>
<p>The Smooth step uses Metropolis-Hastings MCMC to sample from this posterior. The algorithm alternates between:</p>
<ol type="1">
<li>Proposing new hyperparameters <span class="math inline">\(\tau_\eta^*\)</span></li>
<li>Sampling a new latent field <span class="math inline">\(\eta^*\)</span> conditional on <span class="math inline">\(\tau_\eta^*\)</span></li>
<li>Accepting or rejecting the proposal based on the Metropolis-Hastings ratio</li>
</ol>
<section id="latent-field-sampling" class="level3">
<h3 class="anchored" data-anchor-id="latent-field-sampling">Latent Field Sampling</h3>
<p>The latent field is sampled from the conditional normal distribution</p>
<p><span class="math display">\[
\eta \vert \hat\eta, \tau_\eta \sim \mathrm{N}(\mu_{\text{post}}, Q_{\text{post}}),
\]</span></p>
<p>where</p>
<p><span class="math display">\[
Q_{\text{post}} = Q_{\eta y} + Q_\eta
\qquad
\text{and}
\qquad
\mu_{\text{post}} = Q_{\text{post}}^{-1}Q_{\eta y}\hat\eta.
\]</span></p>
<p>The first thing we can do to make these calculations faster is to precompute <span class="math inline">\(\hat b_{\eta y} = Q_{\eta y} \hat \eta\)</span> between the Max step and the Smooth step, giving us</p>
<p><span class="math display">\[
Q_{\text{post}} = Q_{\eta y} + Q_\eta
\qquad
\text{and}
\qquad
\mu_{\text{post}} = Q_{\text{post}}^{-1}\hat b_{\eta y}.
\]</span></p>
<p>The most efficient way to sample from this posterior is to calculate the Cholesky decomposition</p>
<p><span class="math display">\[
Q_{\text{post}} = L_{\text{post}}L_{\text{post}}^T,
\]</span></p>
<p>and using that to solve for <span class="math inline">\(\mu_\text{post}\)</span> in</p>
<p><span class="math display">\[
L_{\text{post}}L_{\text{post}}^T \mu_\text{post} = \hat b_{\eta y}.
\]</span></p>
<p>After that, we sample from the latent field by generating a standard normal random vector <span class="math inline">\(z \sim \mathrm N(0, I)\)</span> and using forward substitution to calculate:</p>
<p><span class="math display">\[
\eta^* = \mu_\text{post} + L_\text{post}^{-1}z
\]</span></p>
</section>
</section>
</section>


<div id="quarto-appendix" class="default"><section id="appendix" class="level1 appendix"><h2 class="anchored quarto-appendix-heading">Appendix</h2><div class="quarto-appendix-contents">

<section id="computing-l_textpost" class="level2">
<h2 class="anchored" data-anchor-id="computing-l_textpost">Computing <span class="math inline">\(L_\text{post}\)</span></h2>
<p>We first write out <span class="math inline">\(Q_\text{post}\)</span> as</p>
<p><span class="math display">\[
Q_\text{post} = \begin{bmatrix}
Q_{\psi\psi} + \tau_\psi Q_\text{prior} &amp; Q_{\psi\tau} &amp; Q_{\psi\phi} \\
Q_{\tau\psi} &amp; Q_{\tau\tau} + \tau_\tau Q_\text{prior} &amp; Q_{\tau\phi} \\
Q_{\phi\psi} &amp; Q_{\phi\tau} &amp; Q_{\phi\phi} + \tau_\phi Q_\text{prior},
\end{bmatrix}
\]</span></p>
<p>where each block on the diagonal has bandwidth 3 and all the off-diagonal blocks are diagonal matrices. Keep in mind that since the off-diagonal blocks are diagonal matrices we have that <span class="math inline">\(Q_{\psi\tau} = Q_{\tau\psi}\)</span>, <span class="math inline">\(Q_{\psi\phi} = Q_{\phi\psi}\)</span> and <span class="math inline">\(Q_{\tau\phi} = Q_{\phi\tau}\)</span>. We can thus calculate the Cholesky decomposition</p>
<p><span class="math display">\[
L_\text{post} = \begin{bmatrix}
L_{11} &amp; 0 &amp; 0 \\
L_{21} &amp; L_{22} &amp; 0 \\
L_{31} &amp; L_{32} &amp; L_{33},
\end{bmatrix}
\]</span></p>
<p>efficiently using a block-Cholesky factorization:</p>
<ol type="1">
<li><span class="math inline">\(L_{11} = \mathrm{Chol}(Q_{\psi\psi} + \tau_\psi Q_\text{prior})\)</span></li>
<li><span class="math inline">\(L_{21} = Q_{\psi\tau}L_{11}^{-T}\)</span></li>
<li><span class="math inline">\(L_{31} = Q_{\psi\phi}L_{11}^{-T}\)</span></li>
<li><span class="math inline">\(L_{22} = \mathrm{Chol}(S_{22})\)</span>
<ul>
<li><span class="math inline">\(S_{22} = \left(Q_{\tau\tau} + \tau_\tau Q_\text{prior}\right) - L_{21}L_{21}^T\)</span></li>
</ul></li>
<li><span class="math inline">\(L_{32} = \left(Q_{\tau\phi} - L_{31}L_{21}^T\right)L_{22}^{-T}\)</span></li>
<li><span class="math inline">\(L_{33} = \mathrm{Chol}(S_{33})\)</span>
<ul>
<li><span class="math inline">\(S_{33} = \left( Q_{\phi\phi} + \tau_\phi Q_\text{prior} \right) - L_{31}L_{31}^T - L_{32}L_{32}^T\)</span></li>
</ul></li>
</ol>
</section>
<section id="forward-substitution-solving-ly-b" class="level2">
<h2 class="anchored" data-anchor-id="forward-substitution-solving-ly-b">Forward Substitution: Solving <span class="math inline">\(Ly = b\)</span></h2>
<p>Partition <span class="math inline">\(L\)</span>, <span class="math inline">\(y\)</span> and <span class="math inline">\(b\)</span> conformably:</p>
<p><span class="math display">\[
L_\text{post} = \begin{bmatrix}
L_{11} &amp; 0 &amp; 0 \\
L_{21} &amp; L_{22} &amp; 0 \\
L_{31} &amp; L_{32} &amp; L_{33},
\end{bmatrix} \qquad
y = \begin{bmatrix}
y_1 \\
y_2 \\
y_3
\end{bmatrix} \qquad
b = \begin{bmatrix}
b_1 \\
b_2 \\
b_3
\end{bmatrix}.
\]</span></p>
<section id="first-block-row" class="level3">
<h3 class="anchored" data-anchor-id="first-block-row"><strong>First Block Row</strong></h3>
<p><span class="math display">\[
L_{11} y_1 = b_1
\]</span></p>
<p>Solve for <span class="math inline">\(y_1\)</span>:</p>
<p><span class="math display">\[
y_1 = L_{11}^{-1}b_1
\]</span></p>
</section>
<section id="second-block-row" class="level3">
<h3 class="anchored" data-anchor-id="second-block-row"><strong>Second Block Row</strong></h3>
<p><span class="math display">\[
L_{21}y_1 + L_{22}y_2 = b_2
\]</span></p>
<p>Rearranged:</p>
<p><span class="math display">\[
L_{22}y_2 = b_2 - L_{21}y_1
\]</span></p>
<p>Solve for <span class="math inline">\(y_2\)</span>:</p>
<p><span class="math display">\[
y_2 = L_{22}^{-1}\left(b_2 - L_{21}y_1\right)
\]</span></p>
</section>
<section id="third-block-row" class="level3">
<h3 class="anchored" data-anchor-id="third-block-row"><strong>Third Block Row</strong></h3>
<p><span class="math display">\[
L_{31}y_1 + L_{32}y_2 + L_{33}y_3 = b_3
\]</span></p>
<p>Rearranged:</p>
<p><span class="math display">\[
L_{33}y_3 = b_3 - L_{31}y_1 - L_{32}y_2
\]</span></p>
<p>Solve for <span class="math inline">\(y_3\)</span>:</p>
<p><span class="math display">\[
y_3 = L_{33}^{-1}\left(b_3 - L_{31}y_1 - L_{32}y_2\right)
\]</span></p>
</section>
<section id="combined-solution" class="level3">
<h3 class="anchored" data-anchor-id="combined-solution"><strong>Combined Solution</strong></h3>
<p><span class="math display">\[
y = \begin{bmatrix}
y_1 \\
y_2 \\
y_3
\end{bmatrix} =
\begin{bmatrix}
L_{11}^{-1}b_1 \\
L_{22}^{-1}\left(b_2 - L_{21}y_1\right) \\
L_{33}^{-1}\left(b_3 - L_{31}y_1 - L_{32}y_2\right)
\end{bmatrix}
\]</span></p>
</section>
</section>
<section id="backward-substitution-solving-ltx-y" class="level2">
<h2 class="anchored" data-anchor-id="backward-substitution-solving-ltx-y">Backward Substitution: Solving <span class="math inline">\(L^Tx = y\)</span></h2>
<p>Partition <span class="math inline">\(L^T\)</span> and <span class="math inline">\(x\)</span> like <span class="math inline">\(y\)</span>:</p>
<p><span class="math display">\[
L^T = \begin{bmatrix}
L_{11}^T &amp; L_{21}^T &amp; L_{31}^T \\
0 &amp; L_{22}^T &amp; L_{32}^T \\
0 &amp; 0 &amp; L_{33}^T
\end{bmatrix}, \quad
x = \begin{bmatrix}
x_1 \\
x_2 \\
x_3
\end{bmatrix}
\]</span></p>
<section id="third-block-row-1" class="level3">
<h3 class="anchored" data-anchor-id="third-block-row-1"><strong>Third Block Row</strong></h3>
<p><span class="math display">\[
L_{33}^Tx_3 = y_3
\]</span></p>
<p>Solve for <span class="math inline">\(x_3\)</span></p>
<p><span class="math display">\[
x_3 = L_{33}^{-T}y_3
\]</span></p>
</section>
<section id="second-block-row-1" class="level3">
<h3 class="anchored" data-anchor-id="second-block-row-1"><strong>Second Block Row</strong></h3>
<p><span class="math display">\[
L_{22}^Tx_2 + L_{32}^Tx_3 = y_2
\]</span></p>
<p>Rearranged:</p>
<p><span class="math display">\[
L_{22}^Tx_2 = y_2 - L_{32}^Tx_3
\]</span></p>
<p>Solve for <span class="math inline">\(x_2\)</span></p>
<p><span class="math display">\[
x_2 = L_{22}^{-T}\left(y_2 - L_{32}^Tx_3\right)
\]</span></p>
</section>
<section id="first-block-row-1" class="level3">
<h3 class="anchored" data-anchor-id="first-block-row-1"><strong>First Block Row</strong></h3>
<p><span class="math display">\[
L_{11}^Tx_1 + L_{21}^Tx_2 + L_{31}^Tx_3 = y_1
\]</span></p>
<p>Rearranged:</p>
<p><span class="math display">\[
L_{11}^Tx_1 = y_1 - L_{21}^Tx_2 - L_{31}^Tx_3
\]</span></p>
<p>Solve for <span class="math inline">\(x_1\)</span>:</p>
<p><span class="math display">\[
x_1 = L_{11}^{-T}\left(y_1 - L_{21}^Tx_2 - L_{31}^Tx_3\right)
\]</span></p>
</section>
<section id="combined-solution-1" class="level3">
<h3 class="anchored" data-anchor-id="combined-solution-1"><strong>Combined Solution</strong></h3>
<p><span class="math display">\[
x = \begin{bmatrix}
x_1 \\
x_2 \\
x_3
\end{bmatrix} =
\begin{bmatrix}
L_{11}^{-T}\left(y_1 - L_{21}^Tx_2 - L_{31}^Tx_3\right) \\
L_{22}^{-T}\left(y_2 - L_{32}^Tx_3\right) \\
L_{33}^{-T}y_3
\end{bmatrix}
\]</span></p>
</section>
</section>
<section id="summary-of-forward-backward-step" class="level2">
<h2 class="anchored" data-anchor-id="summary-of-forward-backward-step">Summary of Forward-Backward Step</h2>
<p>First solve <span class="math inline">\(Ly = b\)</span>:</p>
<p><span class="math display">\[
y = \begin{bmatrix}
y_1 \\
y_2 \\
y_3
\end{bmatrix} =
\begin{bmatrix}
L_{11}^{-1}b_1 \\
L_{22}^{-1}\left(b_2 - L_{21}y_1\right) \\
L_{33}^{-1}\left(b_3 - L_{31}y_1 - L_{32}y_2\right)
\end{bmatrix}
\]</span></p>
<p>Then solve <span class="math inline">\(L^Tx = y\)</span></p>
<p><span class="math display">\[
x = \begin{bmatrix}
x_1 \\
x_2 \\
x_3
\end{bmatrix} =
\begin{bmatrix}
L_{11}^{-T}\left(y_1 - L_{21}^Tx_2 - L_{31}^Tx_3\right) \\
L_{22}^{-T}\left(y_2 - L_{32}^Tx_3\right) \\
L_{33}^{-T}y_3
\end{bmatrix}
\]</span></p>
</section>
</div></section></div></main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>