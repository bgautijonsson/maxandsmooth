<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE article PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Archiving
and Interchange DTD v1.2 20190208//EN" "JATS-archivearticle1.dtd">
<article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" dtd-version="1.2" article-type="other">
  <front>
    <article-meta>
      <title-group>
        <article-title>Applying Max-and-Smooth to the UKCP data</article-title>
      </title-group>
      <contrib-group>
        <contrib contrib-type="author">
          <name>
            <surname>Jónsson</surname>
            <given-names>Brynjólfur Gauti Guðrúnar</given-names>
          </name>
          <string-name>Brynjólfur Gauti Guðrúnar Jónsson</string-name>
        </contrib>
      </contrib-group>
      <history/>
    </article-meta>
  </front>
  <body>
    <sec id="introduction">
      <title>Introduction</title>
      <p>This document describes the implementation of the Max-and-Smooth
  algorithm for fast approximate Bayesian inference in spatial extreme
  value analysis of climate projections provided by the UKCP. The
  algorithm is specifically applied to Generalized Extreme Value (GEV)
  distributions and is implemented in C++ with R interfaces using Rcpp
  and RcppEigen as well as Stan.</p>
      <sec id="package-overview">
        <title>Package Overview</title>
        <p>The <monospace>maxandsmooth</monospace> R package provides tools
    for fast approximate Bayesian inference for spatial GEV models. The
    core of the package is implemented in C++ for efficiency, with R
    wrappers for ease of use.</p>
        <p>Key features of the package include:</p>
        <list list-type="bullet">
          <list-item>
            <p>Implementation of the Max-and-Smooth algorithm with Gaussian
        copula dependence</p>
          </list-item>
          <list-item>
            <p>Efficient C++ code using automatic differentiation and
        Eigen</p>
          </list-item>
          <list-item>
            <p>Spatial modeling of GEV parameters using Stan’s efficient HMC
        sampler</p>
          </list-item>
          <list-item>
            <p>R interface for easy integration into existing extreme value
        analysis workflows</p>
          </list-item>
        </list>
      </sec>
      <sec id="algorithm-description">
        <title>Algorithm Description</title>
        <p>The Max-and-Smooth algorithm, as applied to spatial GEV models,
    consists of two main steps:</p>
        <list list-type="order">
          <list-item>
            <p><bold>Max Step</bold>: Maximum likelihood estimation of GEV
        parameters at each spatial location using C++</p>
          </list-item>
          <list-item>
            <p><bold>Smooth Step</bold>: Spatial smoothing of the maximum
        likelihood estimates using a BYM2 model implemented in Stan</p>
          </list-item>
        </list>
        <p>The algorithm treats the ML estimates as sufficient statistics
    for a latent Gaussian field, providing a fast approximation to full
    Bayesian inference for spatial extreme value models.</p>
      </sec>
      <sec id="code-structure">
        <title>Code Structure</title>
        <p>The package is organized into several key files:</p>
        <list list-type="order">
          <list-item>
            <p><monospace>src/gev_reverse_mode.cpp</monospace>: Implements
        the Max step (maximum likelihood estimation for GEV) assuming a
        known Gaussian copula</p>
          </list-item>
          <list-item>
            <p><monospace>Stan/stan_smooth_bym2.stan</monospace> Implements
        the Smooth step using Stan</p>
          </list-item>
        </list>
      </sec>
    </sec>
    <sec id="max-step">
      <title>Max Step</title>
      <p>The Max step involves computing location-wise maximum likelihood
  estimates (MLEs) for the GEV model parameters while accounting for
  spatial dependence through a Matérn-like Gaussian copula
  structure.</p>
      <sec id="data-structure-and-model-specification">
        <title>Data Structure and Model Specification</title>
        <p>Let <inline-formula><alternatives><tex-math><![CDATA[Y]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mi>Y</mml:mi></mml:math></alternatives></inline-formula>
    be an <inline-formula><alternatives><tex-math><![CDATA[n \times p]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:mi>n</mml:mi><mml:mo>×</mml:mo><mml:mi>p</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>
    matrix of observations where:</p>
        <list list-type="bullet">
          <list-item>
            <p>Rows <inline-formula><alternatives><tex-math><![CDATA[(i=1,\ldots,n)]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>…</mml:mi><mml:mo>,</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>
        represent temporal replicates</p>
          </list-item>
          <list-item>
            <p>Columns <inline-formula><alternatives><tex-math><![CDATA[(j=1,\ldots,p)]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>…</mml:mi><mml:mo>,</mml:mo><mml:mi>p</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>
        represent spatial locations</p>
          </list-item>
        </list>
        <p>The model combines GEV marginal distributions with a Gaussian
    copula:</p>
        <list list-type="order">
          <list-item>
            <p><bold>Marginal GEV distributions</bold>: At each location
        <inline-formula><alternatives><tex-math><![CDATA[j]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mi>j</mml:mi></mml:math></alternatives></inline-formula>,
        observations follow a GEV distribution:
        <disp-formula><alternatives><tex-math><![CDATA[Y_{ij} \sim \text{GEV}(\mu_j, \sigma_j, \xi_j)]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block"><mml:mrow><mml:msub><mml:mi>Y</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>∼</mml:mo><mml:mtext mathvariant="normal">GEV</mml:mtext><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>μ</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>σ</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>ξ</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></disp-formula></p>
          </list-item>
          <list-item>
            <p><bold>Spatial dependence</bold>: The dependence structure is
        captured by transforming the observations to standard normal
        using the probability integral transform:
        <disp-formula><alternatives><tex-math><![CDATA[Z_{ij} = \Phi^{-1}(F_{\text{GEV}}(Y_{ij}|\mu_j,\sigma_j,\xi_j))]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block"><mml:mrow><mml:msub><mml:mi>Z</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msup><mml:mi>Φ</mml:mi><mml:mrow><mml:mi>−</mml:mi><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>F</mml:mi><mml:mtext mathvariant="normal">GEV</mml:mtext></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>Y</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false" form="prefix">|</mml:mo><mml:msub><mml:mi>μ</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>σ</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>ξ</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></disp-formula>
        where <inline-formula><alternatives><tex-math><![CDATA[F_{\text{GEV}}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:msub><mml:mi>F</mml:mi><mml:mtext mathvariant="normal">GEV</mml:mtext></mml:msub></mml:math></alternatives></inline-formula>
        is the GEV CDF and <inline-formula><alternatives><tex-math><![CDATA[\Phi^{-1}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:msup><mml:mi>Φ</mml:mi><mml:mrow><mml:mi>−</mml:mi><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:math></alternatives></inline-formula>
        is the standard normal quantile function.</p>
          </list-item>
          <list-item>
            <p><bold>Matérn-like precision structure</bold>: The transformed
        observations follow a multivariate normal distribution with
        precision matrix: <disp-formula><alternatives><tex-math><![CDATA[Q = (Q_{\rho_1} \otimes I_{n_2} + I_{n_1} \otimes Q_{\rho_2})^{\nu+1}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block"><mml:mrow><mml:mi>Q</mml:mi><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>Q</mml:mi><mml:msub><mml:mi>ρ</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:msub><mml:mo>⊗</mml:mo><mml:msub><mml:mi>I</mml:mi><mml:msub><mml:mi>n</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>I</mml:mi><mml:msub><mml:mi>n</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:msub><mml:mo>⊗</mml:mo><mml:msub><mml:mi>Q</mml:mi><mml:msub><mml:mi>ρ</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mrow><mml:mi>ν</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math></alternatives></disp-formula>
        where:</p>
            <list list-type="bullet">
              <list-item>
                <p><inline-formula><alternatives><tex-math><![CDATA[Q_{\rho}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:msub><mml:mi>Q</mml:mi><mml:mi>ρ</mml:mi></mml:msub></mml:math></alternatives></inline-formula>
            is the precision matrix of a standardized AR(1) process</p>
              </list-item>
              <list-item>
                <p><inline-formula><alternatives><tex-math><![CDATA[\otimes]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mi>⊗</mml:mi></mml:math></alternatives></inline-formula>
            denotes the Kronecker product</p>
              </list-item>
              <list-item>
                <p><inline-formula><alternatives><tex-math><![CDATA[\nu]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mi>ν</mml:mi></mml:math></alternatives></inline-formula>
            is a smoothness parameter</p>
              </list-item>
              <list-item>
                <p>The matrix is scaled to ensure unit marginal
            variances</p>
              </list-item>
            </list>
          </list-item>
        </list>
      </sec>
      <sec id="log-likelihood-function">
        <title>Log-likelihood Function</title>
        <p>The total log-likelihood combines the GEV marginal contributions
    and the Gaussian copula:</p>
        <p>
          <disp-formula>
            <alternatives>
              <tex-math><![CDATA[\ell(\theta|Y) = \sum_{j=1}^p \sum_{i=1}^n \ell_{\text{GEV}}(y_{ij}|\mu_j,\sigma_j,\xi_j) + \ell_{\text{copula}}(Z|Q)]]></tex-math>
              <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block">
                <mml:mrow>
                  <mml:mo>ℓ</mml:mo>
                  <mml:mrow>
                    <mml:mo stretchy="true" form="prefix">(</mml:mo>
                    <mml:mi>θ</mml:mi>
                    <mml:mo stretchy="false" form="prefix">|</mml:mo>
                    <mml:mi>Y</mml:mi>
                    <mml:mo stretchy="true" form="postfix">)</mml:mo>
                  </mml:mrow>
                  <mml:mo>=</mml:mo>
                  <mml:munderover>
                    <mml:mo>∑</mml:mo>
                    <mml:mrow>
                      <mml:mi>j</mml:mi>
                      <mml:mo>=</mml:mo>
                      <mml:mn>1</mml:mn>
                    </mml:mrow>
                    <mml:mi>p</mml:mi>
                  </mml:munderover>
                  <mml:munderover>
                    <mml:mo>∑</mml:mo>
                    <mml:mrow>
                      <mml:mi>i</mml:mi>
                      <mml:mo>=</mml:mo>
                      <mml:mn>1</mml:mn>
                    </mml:mrow>
                    <mml:mi>n</mml:mi>
                  </mml:munderover>
                  <mml:msub>
                    <mml:mo>ℓ</mml:mo>
                    <mml:mtext mathvariant="normal">GEV</mml:mtext>
                  </mml:msub>
                  <mml:mrow>
                    <mml:mo stretchy="true" form="prefix">(</mml:mo>
                    <mml:msub>
                      <mml:mi>y</mml:mi>
                      <mml:mrow>
                        <mml:mi>i</mml:mi>
                        <mml:mi>j</mml:mi>
                      </mml:mrow>
                    </mml:msub>
                    <mml:mo stretchy="false" form="prefix">|</mml:mo>
                    <mml:msub>
                      <mml:mi>μ</mml:mi>
                      <mml:mi>j</mml:mi>
                    </mml:msub>
                    <mml:mo>,</mml:mo>
                    <mml:msub>
                      <mml:mi>σ</mml:mi>
                      <mml:mi>j</mml:mi>
                    </mml:msub>
                    <mml:mo>,</mml:mo>
                    <mml:msub>
                      <mml:mi>ξ</mml:mi>
                      <mml:mi>j</mml:mi>
                    </mml:msub>
                    <mml:mo stretchy="true" form="postfix">)</mml:mo>
                  </mml:mrow>
                  <mml:mo>+</mml:mo>
                  <mml:msub>
                    <mml:mo>ℓ</mml:mo>
                    <mml:mtext mathvariant="normal">copula</mml:mtext>
                  </mml:msub>
                  <mml:mrow>
                    <mml:mo stretchy="true" form="prefix">(</mml:mo>
                    <mml:mi>Z</mml:mi>
                    <mml:mo stretchy="false" form="prefix">|</mml:mo>
                    <mml:mi>Q</mml:mi>
                    <mml:mo stretchy="true" form="postfix">)</mml:mo>
                  </mml:mrow>
                </mml:mrow>
              </mml:math>
            </alternatives>
          </disp-formula>
        </p>
        <p>where:</p>
        <list list-type="order">
          <list-item>
            <p>The GEV log-likelihood for a single observation is:
        <disp-formula><alternatives><tex-math><![CDATA[\ell_{\text{GEV}}(y|\mu,\sigma,\xi) = -\log\sigma - (1+\frac{1}{\xi})\log(1+\xi\frac{y-\mu}{\sigma}) - (1+\xi\frac{y-\mu}{\sigma})^{-1/\xi}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block"><mml:mrow><mml:msub><mml:mo>ℓ</mml:mo><mml:mtext mathvariant="normal">GEV</mml:mtext></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>y</mml:mi><mml:mo stretchy="false" form="prefix">|</mml:mo><mml:mi>μ</mml:mi><mml:mo>,</mml:mo><mml:mi>σ</mml:mi><mml:mo>,</mml:mo><mml:mi>ξ</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi>−</mml:mi><mml:mo>log</mml:mo><mml:mi>σ</mml:mi><mml:mo>−</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mi>ξ</mml:mi></mml:mfrac><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>log</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mi>ξ</mml:mi><mml:mfrac><mml:mrow><mml:mi>y</mml:mi><mml:mo>−</mml:mo><mml:mi>μ</mml:mi></mml:mrow><mml:mi>σ</mml:mi></mml:mfrac><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:msup><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mi>ξ</mml:mi><mml:mfrac><mml:mrow><mml:mi>y</mml:mi><mml:mo>−</mml:mo><mml:mi>μ</mml:mi></mml:mrow><mml:mi>σ</mml:mi></mml:mfrac><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mrow><mml:mi>−</mml:mi><mml:mn>1</mml:mn><mml:mi>/</mml:mi><mml:mi>ξ</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></alternatives></disp-formula></p>
          </list-item>
          <list-item>
            <p>The Gaussian copula log-likelihood is:
        <disp-formula><alternatives><tex-math><![CDATA[\ell_{\text{copula}}(Z|Q) = \frac{1}{2}\log|Q| - \frac{1}{2}Z^TQZ + \frac{1}{2}Z^TZ]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block"><mml:mrow><mml:msub><mml:mo>ℓ</mml:mo><mml:mtext mathvariant="normal">copula</mml:mtext></mml:msub><mml:mo stretchy="false" form="prefix">(</mml:mo><mml:mi>Z</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">|</mml:mo><mml:mi>Q</mml:mi><mml:mo stretchy="false" form="postfix">)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mn>2</mml:mn></mml:mfrac><mml:mo>log</mml:mo><mml:mo stretchy="true" form="postfix">|</mml:mo></mml:mrow><mml:mi>Q</mml:mi><mml:mo stretchy="false" form="prefix">|</mml:mo><mml:mi>−</mml:mi><mml:mfrac><mml:mn>1</mml:mn><mml:mn>2</mml:mn></mml:mfrac><mml:msup><mml:mi>Z</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:mi>Q</mml:mi><mml:mi>Z</mml:mi><mml:mo>+</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mn>2</mml:mn></mml:mfrac><mml:msup><mml:mi>Z</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:mi>Z</mml:mi></mml:mrow></mml:math></alternatives></disp-formula>
        where the last term accounts for the standard normal
        margins.</p>
          </list-item>
        </list>
      </sec>
      <sec id="implementation-details">
        <title>Implementation Details</title>
        <p>The optimization is performed using automatic differentiation and
    the L-BFGS algorithm. Key implementation features include:</p>
        <list list-type="order">
          <list-item>
            <p><bold>Parameter transformations</bold>:
        <disp-formula><alternatives><tex-math><![CDATA[(\psi,\tau,\phi) = (\log\mu, \log\sigma-\log\mu, \text{logit}(\xi))]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block"><mml:mrow><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>ψ</mml:mi><mml:mo>,</mml:mo><mml:mi>τ</mml:mi><mml:mo>,</mml:mo><mml:mi>ϕ</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mo>log</mml:mo><mml:mi>μ</mml:mi><mml:mo>,</mml:mo><mml:mo>log</mml:mo><mml:mi>σ</mml:mi><mml:mo>−</mml:mo><mml:mo>log</mml:mo><mml:mi>μ</mml:mi><mml:mo>,</mml:mo><mml:mtext mathvariant="normal">logit</mml:mtext><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>ξ</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></disp-formula></p>
          </list-item>
          <list-item>
            <p><bold>Efficient computation</bold> of the quadratic form
        <inline-formula><alternatives><tex-math><![CDATA[Z^TQZ]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:msup><mml:mi>Z</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:mi>Q</mml:mi><mml:mi>Z</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>
        and log-determinant <inline-formula><alternatives><tex-math><![CDATA[\log|Q|]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:mo>log</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">|</mml:mo><mml:mi>Q</mml:mi><mml:mo stretchy="true" form="postfix">|</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>
        by exploiting the Kronecker structure of the precision
        matrix</p>
          </list-item>
          <list-item>
            <p><bold>Probability integral transform</bold> using accurate
        approximations to the GEV CDF and normal quantile function</p>
          </list-item>
          <list-item>
            <p><bold>Automatic differentiation</bold> (using autodiff’s
        reverse mode) for accurate gradient and Hessian computation</p>
          </list-item>
        </list>
      </sec>
    </sec>
    <sec id="smooth-step">
      <title>Smooth Step</title>
      <p>The Smooth step performs Bayesian inference on the latent parameter
  fields using the maximum likelihood estimates from the Max step as
  noisy observations. We implement this using Stan’s efficient
  Hamiltonian Monte Carlo sampler with a BYM2 (Besag-York-Mollié)
  spatial model.</p>
      <sec id="model-structure">
        <title>Model Structure</title>
        <p>Let <inline-formula><alternatives><tex-math><![CDATA[\hat{\eta}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mover><mml:mi>η</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover></mml:math></alternatives></inline-formula>
    be the vector of maximum likelihood estimates from the Max step,
    arranged as:</p>
        <p>
          <disp-formula>
            <alternatives>
              <tex-math><![CDATA[\hat{\eta} = (\hat{\psi}_1,\ldots,\hat{\psi}_p, \hat{\tau}_1,\ldots,\hat{\tau}_p, \hat{\phi}_1,\ldots,\hat{\phi}_p)^T]]></tex-math>
              <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block">
                <mml:mrow>
                  <mml:mover>
                    <mml:mi>η</mml:mi>
                    <mml:mo accent="true">̂</mml:mo>
                  </mml:mover>
                  <mml:mo>=</mml:mo>
                  <mml:msup>
                    <mml:mrow>
                      <mml:mo stretchy="true" form="prefix">(</mml:mo>
                      <mml:msub>
                        <mml:mover>
                          <mml:mi>ψ</mml:mi>
                          <mml:mo accent="true">̂</mml:mo>
                        </mml:mover>
                        <mml:mn>1</mml:mn>
                      </mml:msub>
                      <mml:mo>,</mml:mo>
                      <mml:mi>…</mml:mi>
                      <mml:mo>,</mml:mo>
                      <mml:msub>
                        <mml:mover>
                          <mml:mi>ψ</mml:mi>
                          <mml:mo accent="true">̂</mml:mo>
                        </mml:mover>
                        <mml:mi>p</mml:mi>
                      </mml:msub>
                      <mml:mo>,</mml:mo>
                      <mml:msub>
                        <mml:mover>
                          <mml:mi>τ</mml:mi>
                          <mml:mo accent="true">̂</mml:mo>
                        </mml:mover>
                        <mml:mn>1</mml:mn>
                      </mml:msub>
                      <mml:mo>,</mml:mo>
                      <mml:mi>…</mml:mi>
                      <mml:mo>,</mml:mo>
                      <mml:msub>
                        <mml:mover>
                          <mml:mi>τ</mml:mi>
                          <mml:mo accent="true">̂</mml:mo>
                        </mml:mover>
                        <mml:mi>p</mml:mi>
                      </mml:msub>
                      <mml:mo>,</mml:mo>
                      <mml:msub>
                        <mml:mover>
                          <mml:mi>ϕ</mml:mi>
                          <mml:mo accent="true">̂</mml:mo>
                        </mml:mover>
                        <mml:mn>1</mml:mn>
                      </mml:msub>
                      <mml:mo>,</mml:mo>
                      <mml:mi>…</mml:mi>
                      <mml:mo>,</mml:mo>
                      <mml:msub>
                        <mml:mover>
                          <mml:mi>ϕ</mml:mi>
                          <mml:mo accent="true">̂</mml:mo>
                        </mml:mover>
                        <mml:mi>p</mml:mi>
                      </mml:msub>
                      <mml:mo stretchy="true" form="postfix">)</mml:mo>
                    </mml:mrow>
                    <mml:mi>T</mml:mi>
                  </mml:msup>
                </mml:mrow>
              </mml:math>
            </alternatives>
          </disp-formula>
        </p>
        <p>where <inline-formula><alternatives><tex-math><![CDATA[p]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mi>p</mml:mi></mml:math></alternatives></inline-formula>
    is the number of spatial locations and
    <inline-formula><alternatives><tex-math><![CDATA[(\hat{\psi}, \hat{\tau}, \hat{\phi})]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mover><mml:mi>ψ</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mo>,</mml:mo><mml:mover><mml:mi>τ</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mo>,</mml:mo><mml:mover><mml:mi>ϕ</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>
    represent the transformed GEV parameters.</p>
        <sec id="spatial-random-effects">
          <title>Spatial Random Effects</title>
          <p>For each parameter type <inline-formula><alternatives><tex-math><![CDATA[k \in \{\psi, \tau, \phi\}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:mi>k</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false" form="prefix">{</mml:mo><mml:mi>ψ</mml:mi><mml:mo>,</mml:mo><mml:mi>τ</mml:mi><mml:mo>,</mml:mo><mml:mi>ϕ</mml:mi><mml:mo stretchy="false" form="postfix">}</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>,
      we decompose the spatial variation into structured and
      unstructured components following the BYM2 parameterization:</p>
          <p>
            <disp-formula>
              <alternatives>
                <tex-math><![CDATA[\eta_k = \mu_k\mathbf{1} + \sigma_k\left(\sqrt{\frac{\rho_k}{c}}\eta^{\text{spatial}}_k + \sqrt{1-\rho_k}\eta^{\text{random}}_k\right)]]></tex-math>
                <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block">
                  <mml:mrow>
                    <mml:msub>
                      <mml:mi>η</mml:mi>
                      <mml:mi>k</mml:mi>
                    </mml:msub>
                    <mml:mo>=</mml:mo>
                    <mml:msub>
                      <mml:mi>μ</mml:mi>
                      <mml:mi>k</mml:mi>
                    </mml:msub>
                    <mml:mn>𝟏</mml:mn>
                    <mml:mo>+</mml:mo>
                    <mml:msub>
                      <mml:mi>σ</mml:mi>
                      <mml:mi>k</mml:mi>
                    </mml:msub>
                    <mml:mrow>
                      <mml:mo stretchy="true" form="prefix">(</mml:mo>
                      <mml:msqrt>
                        <mml:mfrac>
                          <mml:msub>
                            <mml:mi>ρ</mml:mi>
                            <mml:mi>k</mml:mi>
                          </mml:msub>
                          <mml:mi>c</mml:mi>
                        </mml:mfrac>
                      </mml:msqrt>
                      <mml:msubsup>
                        <mml:mi>η</mml:mi>
                        <mml:mi>k</mml:mi>
                        <mml:mtext mathvariant="normal">spatial</mml:mtext>
                      </mml:msubsup>
                      <mml:mo>+</mml:mo>
                      <mml:msqrt>
                        <mml:mrow>
                          <mml:mn>1</mml:mn>
                          <mml:mo>−</mml:mo>
                          <mml:msub>
                            <mml:mi>ρ</mml:mi>
                            <mml:mi>k</mml:mi>
                          </mml:msub>
                        </mml:mrow>
                      </mml:msqrt>
                      <mml:msubsup>
                        <mml:mi>η</mml:mi>
                        <mml:mi>k</mml:mi>
                        <mml:mtext mathvariant="normal">random</mml:mtext>
                      </mml:msubsup>
                      <mml:mo stretchy="true" form="postfix">)</mml:mo>
                    </mml:mrow>
                  </mml:mrow>
                </mml:math>
              </alternatives>
            </disp-formula>
          </p>
          <p>where:</p>
          <list list-type="bullet">
            <list-item>
              <p><inline-formula><alternatives><tex-math><![CDATA[\mu_k]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:msub><mml:mi>μ</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:math></alternatives></inline-formula>
          is the overall mean</p>
            </list-item>
            <list-item>
              <p><inline-formula><alternatives><tex-math><![CDATA[\sigma_k > 0]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:msub><mml:mi>σ</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo>&gt;</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></alternatives></inline-formula>
          is the marginal standard deviation</p>
            </list-item>
            <list-item>
              <p><inline-formula><alternatives><tex-math><![CDATA[\rho_k \in [0,1]]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:msub><mml:mi>ρ</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>
          is the mixing parameter controlling the balance between
          spatial and unstructured variation</p>
            </list-item>
            <list-item>
              <p><inline-formula><alternatives><tex-math><![CDATA[c]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mi>c</mml:mi></mml:math></alternatives></inline-formula>
          is a scaling factor that ensures the marginal variance of the
          spatial component is approximately 1</p>
            </list-item>
            <list-item>
              <p><inline-formula><alternatives><tex-math><![CDATA[\eta^{\text{spatial}}_k]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:msubsup><mml:mi>η</mml:mi><mml:mi>k</mml:mi><mml:mtext mathvariant="normal">spatial</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula>
          follows an intrinsic conditional autoregressive (ICAR)
          prior</p>
            </list-item>
            <list-item>
              <p><inline-formula><alternatives><tex-math><![CDATA[\eta^{\text{random}}_k \sim \mathcal{N}(0, I)]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:msubsup><mml:mi>η</mml:mi><mml:mi>k</mml:mi><mml:mtext mathvariant="normal">random</mml:mtext></mml:msubsup><mml:mo>∼</mml:mo><mml:mi>𝒩</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mi>I</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>
          represents unstructured random effects</p>
            </list-item>
          </list>
        </sec>
        <sec id="icar-prior-specification">
          <title>ICAR Prior Specification</title>
          <p>The ICAR prior for the spatial component
      <inline-formula><alternatives><tex-math><![CDATA[\eta^{\text{spatial}}_k]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:msubsup><mml:mi>η</mml:mi><mml:mi>k</mml:mi><mml:mtext mathvariant="normal">spatial</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula>
      is specified through its full conditional distributions:</p>
          <p>
            <disp-formula>
              <alternatives>
                <tex-math><![CDATA[\eta^{\text{spatial}}_{k,i} | \eta^{\text{spatial}}_{k,-i} \sim \mathcal{N}\left(\frac{1}{n_i}\sum_{j \sim i} \eta^{\text{spatial}}_{k,j}, \frac{1}{n_i}\right)]]></tex-math>
                <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block">
                  <mml:mrow>
                    <mml:msubsup>
                      <mml:mi>η</mml:mi>
                      <mml:mrow>
                        <mml:mi>k</mml:mi>
                        <mml:mo>,</mml:mo>
                        <mml:mi>i</mml:mi>
                      </mml:mrow>
                      <mml:mtext mathvariant="normal">spatial</mml:mtext>
                    </mml:msubsup>
                    <mml:mo stretchy="false" form="prefix">|</mml:mo>
                    <mml:msubsup>
                      <mml:mi>η</mml:mi>
                      <mml:mrow>
                        <mml:mi>k</mml:mi>
                        <mml:mo>,</mml:mo>
                        <mml:mi>−</mml:mi>
                        <mml:mi>i</mml:mi>
                      </mml:mrow>
                      <mml:mtext mathvariant="normal">spatial</mml:mtext>
                    </mml:msubsup>
                    <mml:mo>∼</mml:mo>
                    <mml:mi>𝒩</mml:mi>
                    <mml:mrow>
                      <mml:mo stretchy="true" form="prefix">(</mml:mo>
                      <mml:mfrac>
                        <mml:mn>1</mml:mn>
                        <mml:msub>
                          <mml:mi>n</mml:mi>
                          <mml:mi>i</mml:mi>
                        </mml:msub>
                      </mml:mfrac>
                      <mml:munder>
                        <mml:mo>∑</mml:mo>
                        <mml:mrow>
                          <mml:mi>j</mml:mi>
                          <mml:mo>∼</mml:mo>
                          <mml:mi>i</mml:mi>
                        </mml:mrow>
                      </mml:munder>
                      <mml:msubsup>
                        <mml:mi>η</mml:mi>
                        <mml:mrow>
                          <mml:mi>k</mml:mi>
                          <mml:mo>,</mml:mo>
                          <mml:mi>j</mml:mi>
                        </mml:mrow>
                        <mml:mtext mathvariant="normal">spatial</mml:mtext>
                      </mml:msubsup>
                      <mml:mo>,</mml:mo>
                      <mml:mfrac>
                        <mml:mn>1</mml:mn>
                        <mml:msub>
                          <mml:mi>n</mml:mi>
                          <mml:mi>i</mml:mi>
                        </mml:msub>
                      </mml:mfrac>
                      <mml:mo stretchy="true" form="postfix">)</mml:mo>
                    </mml:mrow>
                  </mml:mrow>
                </mml:math>
              </alternatives>
            </disp-formula>
          </p>
          <p>where <inline-formula><alternatives><tex-math><![CDATA[j \sim i]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:mi>j</mml:mi><mml:mo>∼</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>
      indicates that locations <inline-formula><alternatives><tex-math><![CDATA[i]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mi>i</mml:mi></mml:math></alternatives></inline-formula>
      and <inline-formula><alternatives><tex-math><![CDATA[j]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mi>j</mml:mi></mml:math></alternatives></inline-formula>
      are neighbors, and <inline-formula><alternatives><tex-math><![CDATA[n_i]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:msub><mml:mi>n</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:math></alternatives></inline-formula>
      is the number of neighbors for location
      <inline-formula><alternatives><tex-math><![CDATA[i]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mi>i</mml:mi></mml:math></alternatives></inline-formula>.
      This is implemented efficiently in Stan through the sum of squared
      differences form:</p>
          <p>
            <disp-formula>
              <alternatives>
                <tex-math><![CDATA[p(\eta^{\text{spatial}}_k) \propto \exp\left(-\frac{1}{2}\sum_{i \sim j} (\eta^{\text{spatial}}_{k,i} - \eta^{\text{spatial}}_{k,j})^2\right)]]></tex-math>
                <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block">
                  <mml:mrow>
                    <mml:mi>p</mml:mi>
                    <mml:mrow>
                      <mml:mo stretchy="true" form="prefix">(</mml:mo>
                      <mml:msubsup>
                        <mml:mi>η</mml:mi>
                        <mml:mi>k</mml:mi>
                        <mml:mtext mathvariant="normal">spatial</mml:mtext>
                      </mml:msubsup>
                      <mml:mo stretchy="true" form="postfix">)</mml:mo>
                    </mml:mrow>
                    <mml:mo>∝</mml:mo>
                    <mml:mo>exp</mml:mo>
                    <mml:mrow>
                      <mml:mo stretchy="true" form="prefix">(</mml:mo>
                      <mml:mi>−</mml:mi>
                      <mml:mfrac>
                        <mml:mn>1</mml:mn>
                        <mml:mn>2</mml:mn>
                      </mml:mfrac>
                      <mml:munder>
                        <mml:mo>∑</mml:mo>
                        <mml:mrow>
                          <mml:mi>i</mml:mi>
                          <mml:mo>∼</mml:mo>
                          <mml:mi>j</mml:mi>
                        </mml:mrow>
                      </mml:munder>
                      <mml:msup>
                        <mml:mrow>
                          <mml:mo stretchy="true" form="prefix">(</mml:mo>
                          <mml:msubsup>
                            <mml:mi>η</mml:mi>
                            <mml:mrow>
                              <mml:mi>k</mml:mi>
                              <mml:mo>,</mml:mo>
                              <mml:mi>i</mml:mi>
                            </mml:mrow>
                            <mml:mtext mathvariant="normal">spatial</mml:mtext>
                          </mml:msubsup>
                          <mml:mo>−</mml:mo>
                          <mml:msubsup>
                            <mml:mi>η</mml:mi>
                            <mml:mrow>
                              <mml:mi>k</mml:mi>
                              <mml:mo>,</mml:mo>
                              <mml:mi>j</mml:mi>
                            </mml:mrow>
                            <mml:mtext mathvariant="normal">spatial</mml:mtext>
                          </mml:msubsup>
                          <mml:mo stretchy="true" form="postfix">)</mml:mo>
                        </mml:mrow>
                        <mml:mn>2</mml:mn>
                      </mml:msup>
                      <mml:mo stretchy="true" form="postfix">)</mml:mo>
                    </mml:mrow>
                  </mml:mrow>
                </mml:math>
              </alternatives>
            </disp-formula>
          </p>
          <p>with an additional soft sum-to-zero constraint implemented via
      <inline-formula><alternatives><tex-math><![CDATA[\sum_i \eta^{\text{spatial}}_{k,i} \sim \mathcal{N}(0, 0.001p)]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:msub><mml:mo>∑</mml:mo><mml:mi>i</mml:mi></mml:msub><mml:msubsup><mml:mi>η</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow><mml:mtext mathvariant="normal">spatial</mml:mtext></mml:msubsup><mml:mo>∼</mml:mo><mml:mi>𝒩</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>0.001</mml:mn><mml:mi>p</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>.</p>
        </sec>
        <sec id="observation-model">
          <title>Observation Model</title>
          <p>The observation model links the MLEs to the latent field
      through a multivariate normal distribution:</p>
          <p>
            <disp-formula>
              <alternatives>
                <tex-math><![CDATA[\hat{\eta} | \eta \sim \mathcal{N}(\eta, Q^{-1}_{\eta y})]]></tex-math>
                <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block">
                  <mml:mrow>
                    <mml:mover>
                      <mml:mi>η</mml:mi>
                      <mml:mo accent="true">̂</mml:mo>
                    </mml:mover>
                    <mml:mo stretchy="false" form="prefix">|</mml:mo>
                    <mml:mi>η</mml:mi>
                    <mml:mo>∼</mml:mo>
                    <mml:mi>𝒩</mml:mi>
                    <mml:mrow>
                      <mml:mo stretchy="true" form="prefix">(</mml:mo>
                      <mml:mi>η</mml:mi>
                      <mml:mo>,</mml:mo>
                      <mml:msubsup>
                        <mml:mi>Q</mml:mi>
                        <mml:mrow>
                          <mml:mi>η</mml:mi>
                          <mml:mi>y</mml:mi>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>−</mml:mi>
                          <mml:mn>1</mml:mn>
                        </mml:mrow>
                      </mml:msubsup>
                      <mml:mo stretchy="true" form="postfix">)</mml:mo>
                    </mml:mrow>
                  </mml:mrow>
                </mml:math>
              </alternatives>
            </disp-formula>
          </p>
          <p>where <inline-formula><alternatives><tex-math><![CDATA[Q_{\eta y}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:msub><mml:mi>Q</mml:mi><mml:mrow><mml:mi>η</mml:mi><mml:mi>y</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula>
      is the precision matrix obtained from the negative Hessian in the
      Max step. To handle this efficiently in Stan, we:</p>
          <list list-type="order">
            <list-item>
              <p>Pre-compute the Cholesky factor
          <inline-formula><alternatives><tex-math><![CDATA[L]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mi>L</mml:mi></mml:math></alternatives></inline-formula>
          of <inline-formula><alternatives><tex-math><![CDATA[Q_{\eta y} = LL^T]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:msub><mml:mi>Q</mml:mi><mml:mrow><mml:mi>η</mml:mi><mml:mi>y</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>L</mml:mi><mml:msup><mml:mi>L</mml:mi><mml:mi>T</mml:mi></mml:msup></mml:mrow></mml:math></alternatives></inline-formula></p>
            </list-item>
            <list-item>
              <p>Store <inline-formula><alternatives><tex-math><![CDATA[L]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mi>L</mml:mi></mml:math></alternatives></inline-formula>
          in a sparse format using arrays of indices and values</p>
            </list-item>
            <list-item>
              <p>Implement a custom log probability function that computes:
          <disp-formula><alternatives><tex-math><![CDATA[\log p(\hat{\eta}|\eta) = \frac{1}{2}\log|Q_{\eta y}| - \frac{1}{2}(\hat{\eta} - \eta)^T Q_{\eta y}(\hat{\eta} - \eta)]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block"><mml:mrow><mml:mo>log</mml:mo><mml:mi>p</mml:mi><mml:mo stretchy="false" form="prefix">(</mml:mo><mml:mover><mml:mi>η</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="true" form="prefix">|</mml:mo><mml:mi>η</mml:mi><mml:mo stretchy="false" form="postfix">)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mn>2</mml:mn></mml:mfrac><mml:mo>log</mml:mo><mml:mo stretchy="true" form="postfix">|</mml:mo></mml:mrow><mml:msub><mml:mi>Q</mml:mi><mml:mrow><mml:mi>η</mml:mi><mml:mi>y</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false" form="prefix">|</mml:mo><mml:mi>−</mml:mi><mml:mfrac><mml:mn>1</mml:mn><mml:mn>2</mml:mn></mml:mfrac><mml:msup><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mover><mml:mi>η</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mo>−</mml:mo><mml:mi>η</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mi>T</mml:mi></mml:msup><mml:msub><mml:mi>Q</mml:mi><mml:mrow><mml:mi>η</mml:mi><mml:mi>y</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mover><mml:mi>η</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mo>−</mml:mo><mml:mi>η</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></disp-formula>
          using the sparse Cholesky representation</p>
            </list-item>
          </list>
        </sec>
        <sec id="prior-distributions">
          <title>Prior Distributions</title>
          <p>We specify weakly informative priors:</p>
          <p>
            <disp-formula>
              <alternatives>
                <tex-math><![CDATA[
      \begin{aligned}
      \sigma_k &\sim \text{Exponential}(1) \\
      \rho_k &\sim \text{Beta}(1,1) \\
      \mu_k &\sim \text{flat}
      \end{aligned}
      ]]></tex-math>
                <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block">
                  <mml:mtable>
                    <mml:mtr>
                      <mml:mtd columnalign="right" style="text-align: right">
                        <mml:msub>
                          <mml:mi>σ</mml:mi>
                          <mml:mi>k</mml:mi>
                        </mml:msub>
                      </mml:mtd>
                      <mml:mtd columnalign="left" style="text-align: left">
                        <mml:mo>∼</mml:mo>
                        <mml:mtext mathvariant="normal">Exponential</mml:mtext>
                        <mml:mrow>
                          <mml:mo stretchy="true" form="prefix">(</mml:mo>
                          <mml:mn>1</mml:mn>
                          <mml:mo stretchy="true" form="postfix">)</mml:mo>
                        </mml:mrow>
                      </mml:mtd>
                    </mml:mtr>
                    <mml:mtr>
                      <mml:mtd columnalign="right" style="text-align: right">
                        <mml:msub>
                          <mml:mi>ρ</mml:mi>
                          <mml:mi>k</mml:mi>
                        </mml:msub>
                      </mml:mtd>
                      <mml:mtd columnalign="left" style="text-align: left">
                        <mml:mo>∼</mml:mo>
                        <mml:mtext mathvariant="normal">Beta</mml:mtext>
                        <mml:mrow>
                          <mml:mo stretchy="true" form="prefix">(</mml:mo>
                          <mml:mn>1</mml:mn>
                          <mml:mo>,</mml:mo>
                          <mml:mn>1</mml:mn>
                          <mml:mo stretchy="true" form="postfix">)</mml:mo>
                        </mml:mrow>
                      </mml:mtd>
                    </mml:mtr>
                    <mml:mtr>
                      <mml:mtd columnalign="right" style="text-align: right">
                        <mml:msub>
                          <mml:mi>μ</mml:mi>
                          <mml:mi>k</mml:mi>
                        </mml:msub>
                      </mml:mtd>
                      <mml:mtd columnalign="left" style="text-align: left">
                        <mml:mo>∼</mml:mo>
                        <mml:mtext mathvariant="normal">flat</mml:mtext>
                      </mml:mtd>
                    </mml:mtr>
                  </mml:mtable>
                </mml:math>
              </alternatives>
            </disp-formula>
          </p>
          <p>for each parameter type <inline-formula><alternatives><tex-math><![CDATA[k]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mi>k</mml:mi></mml:math></alternatives></inline-formula>.
      The exponential prior on <inline-formula><alternatives><tex-math><![CDATA[\sigma_k]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:msub><mml:mi>σ</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:math></alternatives></inline-formula>
      provides weak regularization while ensuring positivity, while the
      uniform Beta prior on <inline-formula><alternatives><tex-math><![CDATA[\rho_k]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:msub><mml:mi>ρ</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:math></alternatives></inline-formula>
      allows the data to determine the balance between spatial and
      unstructured variation.</p>
        </sec>
      </sec>
      <sec id="posterior-inference">
        <title>Posterior Inference</title>
        <p>The model is fit using Stan’s implementation of the No-U-Turn
    Sampler (NUTS), providing:</p>
        <list list-type="order">
          <list-item>
            <p>Posterior samples of the latent field
        <inline-formula><alternatives><tex-math><![CDATA[\eta]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mi>η</mml:mi></mml:math></alternatives></inline-formula></p>
          </list-item>
          <list-item>
            <p>Uncertainty quantification through the posterior
        distributions of <inline-formula><alternatives><tex-math><![CDATA[\mu_k]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:msub><mml:mi>μ</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:math></alternatives></inline-formula>,
        <inline-formula><alternatives><tex-math><![CDATA[\sigma_k]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:msub><mml:mi>σ</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:math></alternatives></inline-formula>,
        and <inline-formula><alternatives><tex-math><![CDATA[\rho_k]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:msub><mml:mi>ρ</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:math></alternatives></inline-formula></p>
          </list-item>
          <list-item>
            <p>Decomposition of spatial variation through the posterior
        distributions of <inline-formula><alternatives><tex-math><![CDATA[\eta^{\text{spatial}}_k]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:msubsup><mml:mi>η</mml:mi><mml:mi>k</mml:mi><mml:mtext mathvariant="normal">spatial</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula>
        and <inline-formula><alternatives><tex-math><![CDATA[\eta^{\text{random}}_k]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:msubsup><mml:mi>η</mml:mi><mml:mi>k</mml:mi><mml:mtext mathvariant="normal">random</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula></p>
          </list-item>
        </list>
      </sec>
    </sec>
  </body>
  <back>
</back>
</article>
